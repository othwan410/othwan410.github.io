---
layout: single
title: "해싱"
---

# 해싱

오늘은 해싱에 대해서 공부해보았다.  
공부하면서 적은 것들을 다시 꺼내어 적어보며 정리를 해보려고 한다.  

우선 해싱이라는 것은, 데이터를 쉽게 찾기위해 비교연산을 줄이도록 하는 저장 방법이다.  
키 값을 주면 해시함수가 산술적 연산을 통해 해시 값을 반환하고, 그리고 그 주소에 키 값을 저장한다.  
여기서 포인트는 비교연산이 없이 저장한다는 것이다.  

해시 함수는 탐색키를 입력받아 해시 주소를 생성하는 함수이고,
해시 주소는 배열로 구현된 해시 테이블의 인덱스이다.  

해시 주소가 있는 이 해시테이블은 1차원 혹은 2차원으로 생성할 수 있는데,  
여기서 하나의 행을 버켓이라고 하고, 행의 인덱스 하나하나를 슬롯이라고 한다.  

이러한 해시에서 발생할 수 있는 것은 충돌과 오버플로우이다.  

충돌이란 값은 해시값이 나오면서 같은 버켓에 키 값을 저장해야 하는 상황이다.  
하지만 2차원 배열로 구성된 해시테이블이라면 같은 버켓의 다른 슬롯에 저장하면 된다.  
하지만 그 슬롯마저도 다 찬다면 어떨까?  
그러면 값을 같은 버켓에도 저장하지 못하는 상황이 된다.  

게다가 보통은 슬로의 크기가 1이므로 충돌이 곧 오버플로우인 경우가 많다고 한다.  

이를 해결하기 위해 데이터의 크기만큼 버켓을 늘린다는 것은 매우 공간적으로 비효율 적이다.  
효율적으로 하기 위해선 즉, 데이터의 수보다 버켓을 줄여야 한다는 것이다.  
이말은 또 충돌과 오버플로우가 필연적일 수 있다는 것이 된다.

그렇다면 이 해시를 쓰기 위해서는 반드시 오버플로우를 해결할 방법이 필요하다.  
그 전에 오버플로우가 발생할 상황을 줄이는 것이 우선이지 않을까?  
또, 그렇게 하기 위해서는 해시함수를 잘 설정하는 것이 중요할 것이다.  

이에 대해서는 내일 적어보며 다시 생각해보려고 한다.
